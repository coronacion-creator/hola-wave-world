# 4.2 Conexión con Bases de Datos

El proyecto utiliza una arquitectura híbrida con dos sistemas de bases de datos complementarios:

- **PostgreSQL** (SQL) - Datos relacionales estructurados vía Lovable Cloud/Supabase
- **MongoDB** (NoSQL) - Logs y datos no estructurados vía MongoDB Atlas

---

## 4.2.1 Conexión con Base de Datos SQL (PostgreSQL)

### Archivo: `src/integrations/supabase/client.ts`

Este archivo configura el cliente de Supabase para interactuar con PostgreSQL.

```typescript
// Importamos el creador de clientes de Supabase y los tipos TypeScript
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

// Obtenemos las credenciales desde las variables de entorno
// Estas variables se configuran automáticamente por Lovable Cloud
const SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL;
const SUPABASE_PUBLISHABLE_KEY = import.meta.env.VITE_SUPABASE_PUBLISHABLE_KEY;

// Creamos y exportamos el cliente de Supabase con configuración de autenticación
export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    storage: localStorage,        // Almacena sesión en localStorage del navegador
    persistSession: true,          // Mantiene sesión entre recargas de página
    autoRefreshToken: true,        // Refresca automáticamente el token JWT
  }
});
```

### Explicación línea por línea:

1. **`import { createClient }`**: Importa la función factory de Supabase que crea instancias del cliente
2. **`import type { Database }`**: Importa los tipos TypeScript generados automáticamente desde el esquema de la base de datos
3. **`import.meta.env.VITE_SUPABASE_URL`**: Accede a la variable de entorno con la URL del proyecto Supabase
4. **`createClient<Database>(...)`**: Crea el cliente tipado con el esquema de la base de datos
5. **`storage: localStorage`**: Usa el almacenamiento local del navegador para guardar la sesión del usuario
6. **`persistSession: true`**: Mantiene la sesión activa incluso si el usuario recarga la página
7. **`autoRefreshToken: true`**: Refresca automáticamente el JWT antes de que expire (cada ~1 hora)

### Ejemplo de uso - Consulta SELECT:

```typescript
import { supabase } from '@/integrations/supabase/client';

// Obtener todos los estudiantes activos
const { data, error } = await supabase
  .from('estudiantes')                    // Selecciona la tabla
  .select('id, nombres, apellidos, email') // Columnas a obtener
  .eq('estado', 'activo')                  // Filtro WHERE estado = 'activo'
  .order('apellidos', { ascending: true }); // Ordenar por apellidos A-Z

if (error) {
  console.error('Error al consultar:', error);
} else {
  console.log('Estudiantes:', data);
}
```

### Ejemplo de uso - Inserción UPSERT:

```typescript
// Insertar o actualizar un estudiante
const { data, error } = await supabase
  .from('estudiantes')
  .upsert({
    id: 'uuid-existente',  // Si existe, actualiza; si no, inserta
    nombres: 'Juan',
    apellidos: 'Pérez',
    email: 'juan@example.com',
    dni: '12345678',
    sede_id: 'sede-uuid',
  })
  .select();  // Devuelve el registro insertado/actualizado

console.log('Estudiante guardado:', data);
```

---

## 4.2.2 Conexión con Base de Datos NoSQL (MongoDB)

### Archivo: `src/integrations/mongodb/client.ts`

Este archivo implementa un cliente MongoDB con patrón Singleton para garantizar una única conexión.

```typescript
import { MongoClient, Db, Collection } from 'mongodb';

// Variables globales para mantener la instancia única (Singleton)
let mongoClient: MongoClient | null = null;
let mongoDb: Db | null = null;

/**
 * Obtiene o crea la conexión a MongoDB usando el patrón Singleton
 */
export async function getMongoClient(): Promise<MongoClient> {
  // Si ya existe una conexión activa, la reutilizamos
  if (mongoClient && mongoClient.topology?.isConnected()) {
    return mongoClient;
  }

  // Obtener la URI de conexión desde variables de entorno
  const uri = import.meta.env.VITE_MONGODB_URI;
  
  if (!uri) {
    throw new Error('MONGODB_URI no está definida');
  }

  try {
    // Crear nueva instancia del cliente con opciones optimizadas
    mongoClient = new MongoClient(uri, {
      maxPoolSize: 10,              // Máximo 10 conexiones simultáneas
      minPoolSize: 2,               // Mínimo 2 conexiones en pool
      serverSelectionTimeoutMS: 5000,  // Timeout de 5 segundos
      socketTimeoutMS: 45000,       // Timeout de socket de 45 segundos
    });

    // Conectar al servidor MongoDB Atlas
    await mongoClient.connect();
    console.log('✅ Conexión exitosa a MongoDB Atlas');
    
    return mongoClient;
  } catch (error) {
    console.error('❌ Error al conectar con MongoDB:', error);
    throw error;
  }
}

/**
 * Obtiene la instancia de la base de datos
 */
export async function getDatabase(dbName: string = 'school_management'): Promise<Db> {
  if (mongoDb) {
    return mongoDb;
  }

  const client = await getMongoClient();
  mongoDb = client.db(dbName);  // Selecciona la base de datos
  return mongoDb;
}

/**
 * Obtiene una colección específica con tipado TypeScript
 */
export async function getCollection<T = any>(
  collectionName: string
): Promise<Collection<T>> {
  const db = await getDatabase();
  return db.collection<T>(collectionName);
}
```

### Explicación línea por línea:

1. **`let mongoClient: MongoClient | null = null`**: Variable global que almacena la única instancia del cliente (Singleton)
2. **`mongoClient.topology?.isConnected()`**: Verifica si la conexión existente sigue activa
3. **`maxPoolSize: 10`**: Configura un pool de máximo 10 conexiones concurrentes para optimizar rendimiento
4. **`serverSelectionTimeoutMS: 5000`**: Si no encuentra un servidor en 5 segundos, lanza error
5. **`await mongoClient.connect()`**: Establece la conexión con MongoDB Atlas de forma asíncrona
6. **`client.db(dbName)`**: Selecciona la base de datos específica del proyecto
7. **`db.collection<T>(collectionName)`**: Obtiene una colección con tipado TypeScript para seguridad de tipos

### Ejemplo de uso - Lectura de documentos:

```typescript
import { getCollection } from '@/integrations/mongodb/client';

// Obtener logs de actividad de un estudiante
const collection = await getCollection('estudiantes_logs');

const logs = await collection
  .find({ estudiante_id: 'uuid-123' })  // Filtro de búsqueda
  .sort({ timestamp: -1 })              // Ordenar por fecha descendente
  .limit(10)                            // Limitar a 10 resultados
  .toArray();                           // Convertir cursor a array

console.log('Logs del estudiante:', logs);
```

### Ejemplo de uso - Escritura de documentos:

```typescript
// Insertar un nuevo log de actividad
const collection = await getCollection('estudiantes_logs');

const resultado = await collection.insertOne({
  estudiante_id: 'uuid-123',
  accion: 'login',
  detalles: { 
    ip: '192.168.1.1',
    navegador: 'Chrome' 
  },
  timestamp: new Date(),
});

console.log('Log insertado con ID:', resultado.insertedId);
```

---

## 4.2.3 Conexión Distribuida (SQL + NoSQL)

### Archivo: `src/services/combinedQuery.ts`

Este servicio combina consultas de ambas bases de datos en paralelo para obtener datos de múltiples fuentes.

```typescript
import { supabase } from '@/integrations/supabase/client';
import { getCollection } from '@/integrations/mongodb/client';

/**
 * Consulta distribuida: Perfil completo de estudiante
 * Combina datos estructurados (SQL) con logs de actividad (NoSQL)
 */
export async function obtenerPerfilCompletoEstudiante(estudianteId: string) {
  try {
    // Ejecutar ambas consultas en PARALELO usando Promise.all
    const [datosPostgres, datosMongoResult] = await Promise.all([
      
      // CONSULTA 1: PostgreSQL - Datos del estudiante
      supabase
        .from('estudiantes')
        .select('id, nombres, apellidos, email, dni, estado')
        .eq('id', estudianteId)
        .single(),
      
      // CONSULTA 2: MongoDB - Logs de actividad
      (async () => {
        try {
          const collection = await getCollection('estudiantes_logs');
          
          const logs = await collection
            .find({ estudiante_id: estudianteId })
            .sort({ timestamp: -1 })
            .limit(50)
            .toArray();
          
          return { logs, error: null };
        } catch (error) {
          // Manejo de errores parcial: Si falla MongoDB, devolvemos array vacío
          console.error('Error en MongoDB:', error);
          return { logs: [], error };
        }
      })(),
    ]);

    // Extraer datos con manejo de errores parciales
    const estudiante = datosPostgres.error ? null : datosPostgres.data;
    const logs = datosMongoResult.logs;

    // Calcular estadísticas derivadas
    const estadisticas = {
      total_logs: logs.length,
      ultima_actividad: logs.length > 0 ? logs[0].timestamp : null,
    };

    // Retornar resultado combinado
    return {
      estudiante,
      logs,
      estadisticas,
    };
  } catch (error) {
    console.error('Error en consulta distribuida:', error);
    throw new Error(`Error al obtener perfil completo: ${error}`);
  }
}
```

### Explicación línea por línea:

1. **`await Promise.all([...])`**: Ejecuta múltiples promesas EN PARALELO para optimizar tiempo de respuesta
2. **Primera consulta (PostgreSQL)**: Obtiene datos relacionales del estudiante (nombre, email, etc.)
3. **Segunda consulta (MongoDB)**: Obtiene logs no estructurados de actividad del estudiante
4. **`(async () => { ... })()`**: IIFE (Immediately Invoked Function Expression) asíncrona para manejar MongoDB
5. **Manejo de errores parcial**: Si una DB falla, devolvemos datos parciales en lugar de fallar completamente
6. **`.single()`**: En Supabase, espera un único resultado (lanza error si hay más de uno)
7. **`return { logs: [], error }`**: Si MongoDB falla, devolvemos array vacío pero continuamos
8. **Estadísticas derivadas**: Calculamos métricas combinando datos de ambas fuentes

### Ejemplo de uso del servicio:

```typescript
import { obtenerPerfilCompletoEstudiante } from '@/services/combinedQuery';

// Obtener perfil completo
const perfil = await obtenerPerfilCompletoEstudiante('uuid-del-estudiante');

console.log('Datos SQL:', perfil.estudiante);
console.log('Logs NoSQL:', perfil.logs);
console.log('Estadísticas:', perfil.estadisticas);
```

---

## 4.2.4 Endpoint API (Edge Function)

### Archivo: `supabase/functions/combined-query/index.ts`

Edge Function que expone las consultas distribuidas como API REST.

```typescript
import { serve } from 'https://deno.land/std@0.190.0/http/server.ts';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.75.0';
import { MongoClient } from 'npm:mongodb@6.3.0';

// Headers CORS para permitir llamadas desde el frontend
const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

// Inicializar cliente Supabase con service role key (backend)
const supabase = createClient(
  Deno.env.get('SUPABASE_URL')!,
  Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
);

// Cliente MongoDB con lazy loading
let mongoClient: MongoClient | null = null;

async function getMongoClient(): Promise<MongoClient> {
  if (mongoClient) return mongoClient;
  
  mongoClient = new MongoClient(Deno.env.get('MONGODB_URI')!);
  await mongoClient.connect();
  return mongoClient;
}

const handler = async (req: Request): Promise<Response> => {
  // Manejar preflight CORS
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const { pathname } = new URL(req.url);
    
    // GET /estudiante/:id - Perfil completo
    if (pathname.includes('/estudiante/')) {
      const estudianteId = pathname.split('/').pop();
      
      // Consultas paralelas a ambas DBs
      const [datosSQL, datosNoSQL] = await Promise.all([
        supabase
          .from('estudiantes')
          .select('*')
          .eq('id', estudianteId)
          .single(),
        
        (async () => {
          const client = await getMongoClient();
          const logs = await client
            .db('school_management')
            .collection('estudiantes_logs')
            .find({ estudiante_id: estudianteId })
            .sort({ timestamp: -1 })
            .limit(20)
            .toArray();
          
          return { logs };
        })(),
      ]);

      return new Response(
        JSON.stringify({
          estudiante: datosSQL.data,
          logs: datosNoSQL.logs,
        }),
        { 
          status: 200, 
          headers: { ...corsHeaders, 'Content-Type': 'application/json' } 
        }
      );
    }

    return new Response('Not Found', { status: 404 });
  } catch (error) {
    return new Response(
      JSON.stringify({ error: error.message }),
      { status: 500, headers: corsHeaders }
    );
  }
};

serve(handler);
```

### Explicación línea por línea:

1. **`serve(handler)`**: Inicia el servidor HTTP de Deno que escucha peticiones
2. **`corsHeaders`**: Headers necesarios para permitir llamadas desde dominios diferentes (CORS)
3. **`SUPABASE_SERVICE_ROLE_KEY`**: Clave privilegiada que bypass RLS (solo usar en backend)
4. **`if (req.method === 'OPTIONS')`**: Maneja pre-flight CORS requests
5. **`new URL(req.url).pathname`**: Extrae la ruta de la petición HTTP
6. **`pathname.split('/').pop()`**: Obtiene el último segmento de la URL (el ID)
7. **Lazy loading MongoDB**: Solo conecta si se necesita, reutilizando la conexión
8. **`Promise.all([...])`**: Ejecuta consultas SQL y NoSQL en paralelo
9. **`JSON.stringify(...)`**: Serializa el objeto JavaScript a JSON para la respuesta HTTP

### Llamada desde el frontend:

```typescript
// Llamar al edge function desde React
const { data, error } = await supabase.functions.invoke('combined-query', {
  body: { estudianteId: 'uuid-123' }
});

console.log('Respuesta del backend:', data);
```

---

## 4.2.5 Variables de Entorno

### Archivo: `.env.example`

```bash
# PostgreSQL (Supabase)
VITE_SUPABASE_URL=https://tu-proyecto.supabase.co
VITE_SUPABASE_PUBLISHABLE_KEY=tu-clave-publica-aqui

# MongoDB Atlas
VITE_MONGODB_URI=mongodb+srv://user:pass@cluster.mongodb.net/school_management

# Backend (Edge Functions únicamente)
SUPABASE_SERVICE_ROLE_KEY=tu-service-role-key
MONGODB_URI=mongodb+srv://user:pass@cluster.mongodb.net/school_management
```

### Notas importantes:

- **VITE_**: Prefijo obligatorio para exponer variables en el frontend (Vite)
- **Sin VITE_**: Variables disponibles SOLO en edge functions (backend)
- **PUBLISHABLE_KEY**: Seguro para frontend, respeta RLS
- **SERVICE_ROLE_KEY**: NUNCA exponer en frontend, bypasea RLS

---

## 4.2.6 Recomendaciones de Seguridad

### 1. **Separación de claves**
- ✅ Frontend: Usa `SUPABASE_PUBLISHABLE_KEY`
- ❌ Frontend: NUNCA uses `SERVICE_ROLE_KEY`
- ✅ Backend: Usa `SERVICE_ROLE_KEY` solo en edge functions

### 2. **Row Level Security (RLS)**
```sql
-- Ejemplo: Solo permitir que usuarios vean sus propios datos
CREATE POLICY "Usuarios ven sus propios datos"
ON estudiantes FOR SELECT
USING (auth.uid() = user_id);
```

### 3. **MongoDB IP Whitelist**
- En MongoDB Atlas → Network Access
- Agrega solo IPs necesarias
- En producción, usa VPC peering

### 4. **Gestión de secretos**
- Usa Lovable Cloud Secrets Manager
- NO commits archivos .env en Git
- Rota credenciales cada 90 días

### 5. **Validación de entrada**
```typescript
// Siempre valida inputs del usuario
const schema = z.object({
  email: z.string().email(),
  dni: z.string().length(8),
});

const validated = schema.parse(userInput);
```

### 6. **Rate limiting**
```typescript
// Implementa límites de peticiones
const rateLimit = {
  maxRequests: 100,
  windowMs: 60000, // 1 minuto
};
```

---

## 4.2.7 Diagrama de Flujo de Conexiones

```
┌─────────────┐
│   Frontend  │
│   (React)   │
└──────┬──────┘
       │
       ├──────────────────┐
       │                  │
       ▼                  ▼
┌─────────────┐    ┌──────────────┐
│  PostgreSQL │    │   MongoDB    │
│ (Supabase)  │    │   (Atlas)    │
└─────────────┘    └──────────────┘
       │                  │
       └────────┬─────────┘
                ▼
       ┌─────────────────┐
       │  Edge Function  │
       │ (Consultas      │
       │  Distribuidas)  │
       └─────────────────┘
```

---

## 4.2.8 Conclusión

Esta arquitectura híbrida aprovecha:
- **PostgreSQL**: Datos relacionales, transacciones ACID, joins complejos
- **MongoDB**: Flexibilidad de esquema, alta velocidad de escritura, datos no estructurados
- **Edge Functions**: Lógica de negocio centralizada, consultas optimizadas

Ambas bases de datos se complementan para ofrecer un sistema robusto y escalable.
